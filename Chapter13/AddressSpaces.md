## 13. Address Spaces

### 13.1 초기 시스템 (Early Systems)
 메모리 관점에서, 초기 컴퓨터는 사용자에게 추상화를 제공하지 않았다.컴퓨터의 물리적 메모리는 그림 13.1 과 같이 생겼다.
<img width="296" alt="스크린샷 2023-01-27 오후 2 39 29" src="https://user-images.githubusercontent.com/49808034/215017413-d8fac7e3-36a3-4d9b-b0c1-64abafe269a2.png">  
운영체제는 메모리에 저장된 루틴(라이브러리들)의 집합이었으며, 물리적 메모리에 저장되어 나머지 메모리를 사용하는 하나의 프로그램이었다.  

### 13.2 멀티프로그래밍과 시분할 (Multiprogramming and Time Sharing) 
 컴퓨터는 고가의 장비였기 때문에 사람들은 더 효과적으로 공유하기 시작했다. 그러면서 **멀티프로그래밍** 시대가 도래했다.
 예를 들어, 입출력을 실행하면 CPU는 다른프로세스로 전환하였다. 이런 전환은 CPU 활용도를 높일 수 있었고, 당시 컴퓨터는 엄청난 고가의 장비였기에 이러한 활용도를 높이는 작업은 매우 중요했다.  
 
 
 그 후 사람들은 컴퓨터를 더 많이 사용하길 원했고, **시분할(Time-Sharing)** 시대가 도래한다.  
특히 프로그램-디버깅 주기가 길었기 때문에 많은 사람들이 일괄처리방식(Batch computing)의 한계를 느꼈다. 많은 사용자들이 동시에 컴퓨터를 사용하면서 현재 실행중인 작업으로 부터 즉시 응답을 원했기 때문에 대화식(interactivity) 개념이 중요해졌다.  


한 프로세스를 짧은 시간동안 실행하여 모든 메모리에 대한 액세스 권한을 부여한 다음 해당 프로세스를 중지하고 모든 상태를 디스크에 저장한 후, 다른 프로세스의 상태를 로드하여 잠시동안 실행하여 엉성하지만 시분할을 이런 방식으로 구현하였다.


이 방법은 너무 느리다는 문제가 있었다. 특히 메모리가 커질수록 더욱 느려진다. 레지스터 수준 상태의 저장 및 복원은 빠르지만, 메모리의 전체 내용을 디스크에 저장하는 것은 성능이 떨어진다.
따라서 프로세스를 메모리에 남겨둔 채로 프로세스를 전환하면 운영체제가 Time-Sharing을 효율적으로 할 수 있게 된다.(그림 13.2, 13.3)

<img width="278" alt="스크린샷 2023-01-27 오후 5 01 58" src="https://user-images.githubusercontent.com/49808034/215037067-7d46986b-0ad0-47e0-9ec4-043f7bb36716.png"> <img width="306" alt="스크린샷 2023-01-27 오후 5 02 11" src="https://user-images.githubusercontent.com/49808034/215037101-c00cf108-095b-4cec-9441-bd3c922308ae.png">

13.2 그림을보면, 3개의 프로세스가 512KB의 메모리에 각각 작은 부분들을 차지하고 있다. 단일

따라서 프로세스를 메모리에 남겨둔 채로 프로세스를 전환하면 운영체제가 시분할(Time-Sharing)을 효율적으로 할 수 있게 된다. 단일 CPU라면, 하나의 프로세스가 동작 되는동안 나머지 두 프로세스는 큐에서 대기상태로 대기하게 된다.
시분할을 선호하게 
