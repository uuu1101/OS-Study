## 13. Address Spaces

### 13.1 초기 시스템 (Early Systems)
 메모리 관점에서, 초기 컴퓨터는 사용자에게 추상화를 제공하지 않았다.컴퓨터의 물리적 메모리는 그림 13.1 과 같이 생겼다.
<img width="296" alt="스크린샷 2023-01-27 오후 2 39 29" src="https://user-images.githubusercontent.com/49808034/215017413-d8fac7e3-36a3-4d9b-b0c1-64abafe269a2.png">  
운영체제는 메모리에 저장된 루틴(라이브러리들)의 집합이었으며, 물리적 메모리에 저장되어 나머지 메모리를 사용하는 하나의 프로그램이었다.  

### 13.2 멀티프로그래밍과 시분할 (Multiprogramming and Time Sharing) 
 컴퓨터는 고가의 장비였기 때문에 사람들은 더 효과적으로 공유하기 시작했다. 그러면서 **멀티프로그래밍** 시대가 도래했다.
 예를 들어, 입출력을 실행하면 CPU는 다른프로세스로 전환하였다. 이런 전환은 CPU 활용도를 높일 수 있었고, 당시 컴퓨터는 엄청난 고가의 장비였기에 이러한 활용도를 높이는 작업은 매우 중요했다.  
 
 
 그 후 사람들은 컴퓨터를 더 많이 사용하길 원했고, **시분할(Time-Sharing)** 시대가 도래한다.  
특히 프로그램-디버깅 주기가 길었기 때문에 많은 사람들이 일괄처리방식(Batch computing)의 한계를 느꼈다. 많은 사용자들이 동시에 컴퓨터를 사용하면서 현재 실행중인 작업으로 부터 즉시 응답을 원했기 때문에 대화식(interactivity) 개념이 중요해졌다.  


한 프로세스를 짧은 시간동안 실행하여 모든 메모리에 대한 액세스 권한을 부여한 다음 해당 프로세스를 중지하고 모든 상태를 디스크에 저장한 후, 다른 프로세스의 상태를 로드하여 잠시동안 실행하여 엉성하지만 시분할을 이런 방식으로 구현하였다.


이 방법은 너무 느리다는 문제가 있었다. 특히 메모리가 커질수록 더욱 느려진다. 레지스터 수준 상태의 저장 및 복원은 빠르지만, 메모리의 전체 내용을 디스크에 저장하는 것은 성능이 떨어진다.
따라서 프로세스를 메모리에 남겨둔 채로 프로세스를 전환하면 운영체제가 Time-Sharing을 효율적으로 할 수 있게 된다.(그림 13.2, 13.3)

<img width="278" alt="스크린샷 2023-01-27 오후 5 01 58" src="https://user-images.githubusercontent.com/49808034/215037067-7d46986b-0ad0-47e0-9ec4-043f7bb36716.png"> <img width="306" alt="스크린샷 2023-01-27 오후 5 02 11" src="https://user-images.githubusercontent.com/49808034/215037101-c00cf108-095b-4cec-9441-bd3c922308ae.png">

13.2 그림을보면, 3개의 프로세스가 512KB의 메모리에 각각 작은 부분들을 차지하고 있다. 단일

따라서 프로세스를 메모리에 남겨둔 채로 프로세스를 전환하면 운영체제가 시분할(Time-Sharing)을 효율적으로 할 수 있게 된다. 단일 CPU라면, 하나의 프로세스가 동작 되는동안 나머지 두 프로세스는 큐에서 대기상태로 대기하게 된다.
이렇게 여러 프로그램을 동시에 메모리에 저장하게 되면서 프로세스가 다른 프로세스의 메모리를 읽거나 쓰지 않도록 보호하도록 하는게 중요한 문제로 남게 된다.

### 13.3 주소 공간(The Address Space)
우리는 다른 프로세스의 메모리를 읽거나 쓰지 않도록 운영체제에서 사용하기 쉬운 개념 메모리 개념을 추상화해야했다. 이 개념이 **주소 공간(address space)** 이다. 이는 시스템에서 실행중인 프로그램의 메모리의 모습이다. 프로세스의 주소 공간은 실행 중인 프로그램의 모든 메모리 상태를 포함해야한다. 


예를 들어, 프로그램의 **코드(Code, 명령어)영역**은 반드시 메모리에 존재해야 하고 따라서 주소 공간에 존재한다.  
**스택(Stack)영역**은 함수 호출 체인 상의 현재 위치를 추적하고 지역 변수, 함수 인자와 반환 값등을 저장하는데 사용된다.  
마지막으로 **힙(Heap)영역**은 동적으로 할당되는 메모리를 위해 사용된다.  
정적으로 초기화된 변수등 다른 것들도 있지만, 코드, 스택, 힙 세 가지 영역만 있다고 가정하자.

<img width="319" alt="스크린샷 2023-01-27 오후 5 33 35" src="https://user-images.githubusercontent.com/49808034/215042669-1a0330c6-9a46-4b94-b296-c5ba7b5e15d6.png">
그림 13.3은 16KB의 아주 작은 주소공간이다. 프로그램 코드는 주소 공간의 상단에 위치한다. 위 그림에서는 0KB ~ 1KB에 해당하는 부분이다. 코드는 정적이기 때문에 저장하기 쉽기 때문에 상단에 배치하고 프로그램이 실행되면서 추가 메모리 또한 필요하지 않다.


다음으로 프로그램이 실행되면서 확장되거나 축소될 수 있는 두 종류의 주소공간이 있다. 주소 공간의 상단에 위치한 힙과 하단에 존재하는 스택이다. 확장이 가능하여야 하기 때문에 양 끝단에 배치하는 형태를 띈다. 힙은 코드 바로 뒤 1KB부터 시작하고 아래로 확장되며, 스택은 16KB에서 시작하여 위쪽 방향으로 확장된다. 이러한 배치 방식은 관례일 뿐이며 원하면 다른 방식으로 배치도 가능하다.


추후에 알게 되겠지만, 주소 공간에 여러 쓰레드가 공존할 때는 이런식으로 나누게 되면 동작하지 않는다.


프로그램이 실제 물리적 주소 0 ~ 16KB의 메모리에 존재하는 것은 아니다, 임의의 물리적 주소로 할당된다. 그림 13.2에서 프로세스 A,B,C를 보면 알 수 있듯이 각 프로세스는 다른 주소의 메모리에 로드 된다.

> 그렇다면, 어떻게 운영체제는 단일 물리적 메모리 위에 여러 실행 프로세스를 위한 주소 공간을 추상화 할수 있을까요?  

이러한 일을 하는 것을 **메모리를 가상화(virtualizing memory)한다**고 한다. 프로그램은 자신이 특정 주소의 탑재되고 아주 큰 주소 공간을 차지한다고 생각하고 있지만 실상은 다르다.  

예를 들어 그림 13.2의 프로세스 A가 물리적 주소 0으로 부터 load를 수행하려고 할 때 운영체제는 하드웨어의 지원을 통해 load가 실제로 물리 주소 0이 아니라 물리 주소 320KB로 이동하는지 확인해야한다. 이것이 메모리 가상화의 핵심이다.


### 13.4 목표(Goal)

