## 6. Direct Execution

Time sharing을 통해서 가상화를 구현할 수 있다. 하지만 이를 위해서 몇가지 문제들을 해결해야한다.

첫번째는, 성능 저하 문제
두번째는, 제어 문제

운영체제는 자원관리를 책임지고 있기 때문에, 제어 문제가 중요하다.  

제어권을 상실하면 하나의 프로세스가 영원히 동작하거나 컴퓨터를 장악하거나, 접근해선 안될 정보에도 접근하게 될 수 있다.  
즉, 운영체제를 구축하는데 중요한것은 **제어권을 유지하면서 성능 저하가 없도록 하는 것**이다.

### 6-1. Basic Technique: Limited Direct Execution  

개발자들은 프로그램을 빠르게 실행하기 위해 제한적 직접 실행(Limited Direct Execution)이라는 기법을 개발하였다.
'직접 실행' 이라는 부분은 프로그램을 그냥 CPU 상에서 직접 실행시키는 것이다.  
운영체제가 프로그램을 실행할때 프로세스 리스트에 프로세스를 생성하고 메모리에 할당하며 프로그램 코드를 로드하고 Entry 포인트(ex.main())를 찾아서 그 지점으로부터 사용자 코드를 싱행한다.


<img width="583" alt="직접 실행 방식" src="https://user-images.githubusercontent.com/49808034/212630410-95b82673-f21b-4f68-b308-3d903c87bea2.png">

위 그림은 직접 실행 방식을 보여주고 있다. 프로그램의 main()으로 return to jump 하고 커널로 되돌아가기 위해 일반적인 호출을 사용하였다.

그러나 이러한 직접 실행 방식은 몇가지 문제를 일으킨다.  

- 프로그램을 직접 실행시킨다면, 프로그램이 운영체제가 원치 않는 일을 하지 않는다는 것을 어떻게 보장할 수 있는가?
- 프로세스를 실행 시킬 때, 어떻게 운영체제가 프로그램을 중지하고 다른 프로세스로 전환시킬수 있는가?
  즉, 어떻게 Time Sharing을 구현할 수 있느냐?
  
 ### 6-2. 문제점 1 : 제한된 연산(Restricted Operations)
 
 직접 실행의 장점은 빠르게 실행된다는 것. CPU에서 실행되기 때문이다.
 
 하지만 CPU에서 직접 실행시키면 새로운 문제가 발생한다. 만일 프로세스가 특수한 종류의 연산을 수행하길 원한다면 어떻게 될까? (디스크 입출력 요청 또는 메모리와 같은 시스템 자원에 대한 추가적인 요청)
 프로세스가 원하는 대로 할 수 있게 방치하는 방안이 있다. 그러나 이 방안은 바람직하지 않다. 
 
 예를 들어, 파일에 대한 접근을 허용하기 전에 권한을 검사하는 시스템을 구현한다고 했을 때
 프로세스가 디스크에 대하여 입출력하는 것을 제한하지 않으면 프로세스는 전체 디스크를 읽고 쓸 수 있기 때문에 접근권한을 검사하는 기능은 아무런 의미가없다.
  
 이러한 문제 때문에, **사용자 모드(user mode)** 라고 알려진 새로운 모드가 도입되었다.  
 사용자 모드에서는 실행되는 코드는 할 수 있는 일이 제한된다. 예) 사용자 모드에서 입출력 요청을 할 수 없도록 제한하고, 이때 입출력 요청을 하게되면 프로세서가 예외를 발생시키고, 운영체제는 해당 프로세스를 제거한다.
 
 **커널 모드(kernel mode)** 는 사용자 모드와 대비되는 모드, 운영체제의 중요한 코드들이 실행된다. 이 모드에서 실행되는 코드는 모든 특수한 명령을 포함하여 원하는 모든 작업을 수행할 수있다.
 
 그렇다면, 사용자 프로세스가 디스크 읽기와 같은 특수한 명령어를 실행해야 할 때는 어떻게 해야할까?  
 이러한 제한 작업의 실행을 허용하기 위하여 하드웨어는 사용자 프로세스에게 **시스템 콜**을 제공한다.
 
 **시스템 콜을 실행하기 위해 프로그램은 trap**이라는 특수 명령어를 실행해야한다.  
 이 명령어는 커널 안으로 분기하는 동시에 특권 수준을 커널모드로 상향 조정한다. 커널모드는 모든 명령어를 실행할 수 있다.  
 완료되면 운영체제는 **return-from-trap** 특수 명령어를 호출한다. 이는 특권 수준을 사용자 모드로 다시 하향 조정한다.
 
 **trap**을 실행할때에는 레지스터를 저장해야한다. 예를 들어 x86에서 프로세스를 실행하려면 **kernel stack**에 저장되어 있는 몇몇의 레지스터들(프로그램 카운터, 플래그등)을 pop하여 사용자모드 프로그램을 실행하기 때문이다.
 
 중요한 사항이 남아있는데, **trap**이 운영체제의 코드를 어디를 실행해야할지 어떻게 아냐는것이다.  
 
 커널은 부팅 시에 **트랩 테이블(trap table)** 을 만들고 이를 이용하여 시스템을 통제한다.  
 운영체제가 하는 초기 작업중 하나는 하드웨어에게 예외 사건이 일어났을때 어떤 코드를 실행헤야하는지 알려주는 것이다.
 
 예를 들어, 하드 디스크 인터럽트, 키보드 인터럽트가 발생하면 무슨 코드를 실행해야하는가? 운영체제는 특정 명령어를 사용하여 하드웨어에게 **트랩 번들(trap bundle)** 의 위치를 알려준다.따라서 하드웨어는 해당 위치를 알고 있고, 특정 사건이 발생했을때 어떤 코드를 실행해야하는지 알 수 있다.

시스템 콜은 고유 번호를 갖고 있으며 사용자 프로그램은 원하는 시스템 콜을 호출하기 위해 해당 시스템 콜 번호를 레지스터 또는 스택의 지정된 위치에 저장한다. 운영체제는 시스템 콜 번호를 읽어 유효한 시스템 콜에 해당하는지를 먼저 파악한다.
각 시스템 콜의 코드 위치는 운영체제만 알고 있으며, 사용자 프로그램은 시스템 콜 코드의 정확한 위치를 모른다. 만약 사용자 프로그램이 시스템 콜 코드의 정확한 위치를 알고 있다면, 그 위치로 직접이동하여 커널 코드를 실행하는 경우도 있을 것이다.  
사용자가 시스템 콜 번호를 이용해 커널에게 시스템 콜의 실행요청 하는것은 커널 코드의 무분별한 실행을 방지하기 위함이다.  

Limited Direct Exceution은 두 단계로 진행된다. 부팅 시 커널은 트랩 테이블을 초기화 하고 CPU는 나중에 사용하기 위해 테이블의 위치를 기억한다. 프로세스를 실행할 때 return-from-trap을 이용하여 사용자 프로세스를 시작할 때 몇가지 작업을 수행한다.(새로운 프로세스를 위한 노드 할당, 프로세스 리스트에 삽입, 메모리를 할당 하는 작업등)  

return-from-trap 명령어는 CPU를 사용자 모드로 전환하고 프로세스를 실행한다. 프로세스가 시스템 콜을 호출하면 운영체제로 다시 trap된다. 운영체제는 시스템 콜을 처리하고 return-from-trap 명령어를 사용하여 제어를 프로세스에 넘긴다. 프로세스는 이후 자신의 할일을 다하면 main()에서 return한다. 이후 스텁 코드가 프로그램을 종료하며, 종료시킬 때 exit() 시스템을 호출하고 다시 운영체제로 trap 된다.  

## 6.3 문제점 2 : 프로세스 간 전환  

직접 실행의 두 번째 문제점은 프로세스 전환이 가능해야한다는 점이다. 프로세스의 전환이란 실행 중인 프로세스를 멈추고 다른 프로세스를 실행하는 것이다. 말로는 간단해보이지만, 프로세스가 실행 중이라는 것은 운영체제는 실행 중이지 않다는 것을 의미한다.  
운영체제가 실행되고 있지 않다면 운영체제는 어떠한 조취도 취할수 없기 때문에 프로세스를 전환할 수 없다.  
그렇다면 운영체제는 어떻게 다시 CPU를 획득하여 프로세스를 전환할 수 있을까?

- Cooperative Approach: 시스템 콜을 기다리기  
이 방식은 각 사용자 프로세스가 비정상적인 행동을 하지 않을것이라 가정한다. 다시 말하면, CPU를 장기간 사용해야하는 프로세스들은 다른 프로세스들이 CPU를 사용할 수 있도록 주기적으로 CPU를 반납할 것이라 믿는다. 그렇다면, 어떤식으로 CPU를 반납할까?  
CPU를 반납하기 위해서는 운영체제가 해당 프로세스의 실행상태, 즉 각 레지스터값들을 저장해주어야 한다. 그래야 CPU를 반납했던 프로세스가 추후에 다시 실행될 수있다. CPU 반납 문제의 핵심은 어떻게 제어권을 프로세스에서 운영체제로 넘기느냐인데, 프로세스에서 시스템 콜을 호출하면 자연스럽게 운영체제의 코드가 실행되며, 제어권이 운영체제로 넘어가게 된다.  
협조 방식을 사용하는 운영체제는 **yield** 시스템 콜을 제공하는데 이 시스템 콜은 운영체제에게 제어권을 넘겨서 운영체제가 다른 프로세스를 실행할 수 있도록 하는 일만 한다. 

- Non-Cooperative Approach: OS가 컨트롤을 가져오기
일정 시간마다 인터럽트를 발생(Time interrupt)시켜서 현재 실행중인 프로세스를 멈추고, 운영체제의 미리 설정된 interrupt handler가 실행된다.  
이 때 운영체제가 CPU에 대한 컨트롤을 다시 얻고, 운영체제가 하고싶은 걸 할 수 있다.(현재의 프로세스를 멈추고 다른 프로세스를 시작)
OS는 하드웨어에게 타이머 인터럽트가 발생하면 어떤 코드를 실행해야 하는지 알려줘야 한다. 이는 부팅할 때 알려준다.
부팅 과정 중에 운영체제는 타이머를 시작시켜야 한다. 이 타이머는 끌 수도 있다. (타이머를 켜고 끄는건 privileged operation 이다.)
인터럽트가 발생하면 하드웨어는 실행되던 프로그램의 상태를 저장해야 한다.  
이는 다시 프로그램을 실행 시켜주기 위함이다.


