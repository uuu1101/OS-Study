## 6. Direct Execution

Time sharing을 통해서 가상화를 구현할 수 있다. 하지만 이를 위해서 몇가지 문제들을 해결해야한다.

첫번째는, 성능 저하 문제
두번째는, 제어 문제

운영체제는 자원관리를 책임지고 있기 때문에, 제어 문제가 중요하다.  

제어권을 상실하면 하나의 프로세스가 영원히 동작하거나 컴퓨터를 장악하거나, 접근해선 안될 정보에도 접근하게 될 수 있다.  
즉, 운영체제를 구축하는데 중요한것은 **제어권을 유지하면서 성능 저하가 없도록 하는 것**이다.

### 6-1. Basic Technique: Limited Direct Execution  

개발자들은 프로그램을 빠르게 실행하기 위해 제한적 직접 실행(Limited Direct Execution)이라는 기법을 개발하였다.
'직접 실행' 이라는 부분은 프로그램을 그냥 CPU 상에서 직접 실행시키는 것이다.  
운영체제가 프로그램을 실행할때 프로세스 리스트에 프로세스를 생성하고 메모리에 할당하며 프로그램 코드를 로드하고 Entry 포인트(ex.main())를 찾아서 그 지점으로부터 사용자 코드를 싱행한다.


<img width="583" alt="직접 실행 방식" src="https://user-images.githubusercontent.com/49808034/212630410-95b82673-f21b-4f68-b308-3d903c87bea2.png">

위 그림은 직접 실행 방식을 보여주고 있다. 프로그램의 main()으로 return to jump 하고 커널로 되돌아가기 위해 일반적인 호출을 사용하였다.

그러나 이러한 직접 실행 방식은 몇가지 문제를 일으킨다.  

- 프로그램을 직접 실행시킨다면, 프로그램이 운영체제가 원치 않는 일을 하지 않는다는 것을 어떻게 보장할 수 있는가?
- 프로세스를 실행 시킬 때, 어떻게 운영체제가 프로그램을 중지하고 다른 프로세스로 전환시킬수 있는가?
  즉, 어떻게 Time Sharing을 구현할 수 있느냐?
  
 ### 6-2. 문제점 1 : 제한된 연산(Restricted Operations)
 
 직접 실행의 장점은 빠르게 실행된다는 것. CPU에서 실행되기 때문이다.
 
 하지만 CPU에서 직접 실행시키면 새로운 문제가 발생한다. 만일 프로세스가 특수한 종류의 연산을 수행하길 원한다면 어떻게 될까? (디스크 입출력 요청 또는 메모리와 같은 시스템 자원에 대한 추가적인 요청)
 프로세스가 원하는 대로 할 수 있게 방치하는 방안이 있다. 그러나 이 방안은 바람직하지 않다. 
 
 예를 들어, 파일에 대한 접근을 허용하기 전에 권한을 검사하는 시스템을 구현한다고 했을 때
 프로세스가 디스크에 대하여 입출력하는 것을 제한하지 않으면 프로세스는 전체 디스크를 읽고 쓸 수 있기 때문에 접근권한을 검사하는 기능은 아무런 의미가없다.
  
 이러한 문제 때문에, **사용자 모드(user mode)** 라고 알려진 새로운 모드가 도입되었다.  
 사용자 모드에서는 실행되는 코드는 할 수 있는 일이 제한된다. 예) 사용자 모드에서 입출력 요청을 할 수 없도록 제한하고, 이때 입출력 요청을 하게되면 프로세서가 예외를 발생시키고, 운영체제는 해당 프로세스를 제거한다.
 
 **커널 모드(kernel mode)** 는 사용자 모드와 대비되는 모드, 운영체제의 중요한 코드들이 실행된다. 이 모드에서 실행되는 코드는 모든 특수한 명령을 포함하여 원하는 모든 작업을 수행할 수있다.
 
 그렇다면, 사용자 프로세스가 디스크 읽기와 같은 특수한 명령어를 실행해야 할 때는 어떻게 해야할까?  
 이러한 제한 작업의 실행을 허용하기 위하여 하드웨어는 사용자 프로세스에게 **시스템 콜**을 제공한다.
 
 **시스템 콜을 실행하기 위해 프로그램은 trap**이라는 특수 명령어를 실행해야한다.  
 이 명령어는 커널 안으로 분기하는 동시에 특권 수준을 커널모드로 상향 조정한다. 커널모드는 모든 명령어를 실행할 수 있다.  
 완료되면 운영체제는 **return-from-trap** 특수 명령어를 호출한다. 이는 특권 수준을 사용자 모드로 다시 하향 조정한다.
 
 **trap**을 실행할때에는 레지스터를 저장해야한다. 예를 들어 x86에서 프로세스를 실행하려면 **kernel stack**에 저장되어 있는 몇몇의 레지스터들(프로그램 카운터, 플래그등)을 pop하여 사용자모드 프로그램을 실행하기 때문이다.
 
 중요한 사항이 남아있는데, **trap**이 운영체제의 코드를 어디를 실행해야할지 어떻게 아냐는것이다.  
 
 커널은 부팅 시에 **트랩 테이블(trap table)** 을 만들고 이를 이용하여 시스템을 통제한다.  
 운영체제가 하는 초기 작업중 하나는 하드웨어에게 예외 사건이 일어났을때 어떤 코드를 실행헤야하는지 알려주는 것이다.  
 예를 들어, 하드 디스크 인터럽트, 키보드 인터럽트가 발생하면 무슨 코드를 실행해야하는가? 운영체제는 특정 명령어를 사용하여 하드웨어에게 **트랩 번들(trap bundle)** 의 위치를 알려준다.따라서 하드웨어는 해당 위치를 알고 있고, 특정 사건이 발생했을때 어떤 코드를 실행해야하는지 알 수 있다.
 
